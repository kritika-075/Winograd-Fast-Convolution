# -*- coding: utf-8 -*-
"""parallel_wingrad.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vFIMlTweEAr1JNvNP9nBG8iwtqZfj_T2
"""

!pip install pymp-pypi

import pymp
import numpy as np
from __future__ import print_function
from sympy import symbols, Matrix, Poly, zeros, eye, Indexed, simplify, IndexedBase, init_printing, pprint
from operator import mul
from functools import reduce

def parallel_At(a,m,n):
  arr = pymp.shared.array((m,n),dtype='int')
  with pymp.Parallel(4) as p:
    for i in p.range(m):
      for j in range(n):
        arr[i][j] = a[i]**j
  return Matrix(arr)

def parallel_A(a,m,n):
    xp = parallel_At(a,m-1,n)
    flat_list = pymp.shared.array((xp.shape[1],), dtype='int')
    with pymp.Parallel(4) as p:
        for j in range(xp.shape[1]):
            if(j==n-1):
                flat_list[j] = 1
            else:
                flat_list[j] = 0
    return xp.row_insert(m-1,Matrix(1,n,flat_list))

def parallel_T(a,n):
    identity_matrix=Matrix.eye(n)
    ex_array=pymp.shared.array((n,),dtype='int')
    with pymp.Parallel(4) as p:
        for index in p.range(0,n):
            ex_array[index] = (-a[index])**n
    identity_matrix=identity_matrix.row_insert(n+1,Matrix(1,n,ex_array))
    return identity_matrix.T

def parallel_F(a,n):
    Fmatrix=[]
    for i in range(0,n):
      ex_array=pymp.shared.array((n,),dtype='int')
      with pymp.Parallel(4) as p:
          for index in p.range(0,n):
              if(i==index):
                ex_array[index]=1
              else:
                ex_array[index] = a[i]-a[index]
      ans_mul=reduce(mul,ex_array,1)
      Fmatrix.append(ans_mul)     
    return Matrix(n,1,Fmatrix)

def parallel_Fdiag(a,n):
    f=parallel_F(a,n)
    Fmatrix=[]
    for i in range(0,n):
      ex_array=pymp.shared.array((n,),dtype='int')
      with pymp.Parallel(4) as p:
          for index in p.range(0,n):
              if(i==index):
                ex_array[index]=f[i,0]
              else:
                ex_array[index] = 0
      Fmatrix.append(ex_array)     
    return Matrix(Fmatrix)

def parallel_FdiagPlus1(a,n):
    f = parallel_Fdiag(a,n-1)
    # flat_col_list = pymp.shared()
    f = f.col_insert(n-1,zeros(n-1,1))
    flat_list = pymp.shared.array((f.shape[1],), dtype='uint8')
    with pymp.Parallel(4) as p:
        for j in range(f.shape[1]):
            if(j==n-1):
                flat_list[j] = 1
            else:
                flat_list[j] = 0
    return f.row_insert(n-1,Matrix(1,n,flat_list))

def parallel_Lx(a,n):
    x=symbols('x')
    return Matrix(n, 1, lambda i,j: Poly((reduce(mul, ((x-a[k] if k!=i else 1) for k in range(0,n)), 1)).expand(basic=True), x))

def parallel_L(a,n):
    lx = parallel_Lx(a,n)
    f = parallel_F(a, n)
    return Matrix(n, n, lambda i,j: lx[i, 0].nth(j)/f[i]).T

def Bt(a,n):
    return parallel_L(a,n)*parallel_T(a,n)

def parallel_B(a,n):
    xp = Bt(a,n-1)     
    flat_list = pymp.shared.array((xp.shape[1],), dtype='uint8')
    with pymp.Parallel(4) as p:
        for j in range(xp.shape[1]):
            if(j==n-1):
                flat_list[j] = 1
            else:
                flat_list[j] = 0
    return xp.row_insert(n-1,Matrix(1,n,flat_list))

FractionsInG=0
FractionsInA=1
FractionsInB=2
FractionsInF=3

def winograd_Filter(a,n,r,fractionsIn=FractionsInG):
    alpha = n+r-1
    f = parallel_FdiagPlus1(a,alpha)
    if f[0,0] < 0:
        f[0,:] *= -1
    if fractionsIn == FractionsInG:
        AT = parallel_A(a,alpha,n).T
        G = (parallel_A(a,alpha,r).T/f).T
        BT = f * parallel_B(a,alpha).T
    elif fractionsIn == FractionsInA:
        BT = f * parallel_B(a,alpha).T
        G = parallel_A(a,alpha,r)
        AT = (parallel_A(a,alpha,n)).T/f
    elif fractionsIn == FractionsInB:
        AT = parallel_A(a,alpha,n).T
        G = parallel_A(a,alpha,r)
        BT = parallel_B(a,alpha).T
    else:
        AT = parallel_A(a,alpha,n).T
        G = parallel_A(a,alpha,r)
        BT = f * parallel_B(a,alpha).T
    return (AT,G,BT,f)


def filterVerify(n, r, AT, G, BT):

    alpha = n+r-1

    di = IndexedBase('d')
    gi = IndexedBase('g')
    d = Matrix(alpha, 1, lambda i,j: di[i])
    g = Matrix(r, 1, lambda i,j: gi[i])

    V = BT*d
    U = G*g
    M = U.multiply_elementwise(V)
    Y = simplify(AT*M)

    return Y
def convolutionVerify(a,g,n, r, B, G, A):

    di = a
    gi = g

    d = Matrix(n, 1, lambda i,j: di[i])

    g = Matrix(r, 1, lambda i,j: gi[i])
    print(d)
    print(g)
    V = A*d
    U = G*g
    M = U.multiply_elementwise(V)
    Y = simplify(B*M)

    return Y

def show_winograd_Filter(a,n,r,fractionsIn=FractionsInG):

    AT,G,BT,f = winograd_Filter(a,n,r,fractionsIn)

    print ("AT = ")
    pprint(AT)
    print ("")

    print ("G = ")
    pprint(G)
    print ("")

    print ("BT = ")
    pprint(BT)
    print ("")

    if fractionsIn != FractionsInF:
        print ("FIR filter: AT*((G*g)(BT*d)) =")
        pprint(filterVerify(n,r,AT,G,BT))
        print ("")

    if fractionsIn == FractionsInF:
        print ("fractions = ")
        pprint(f)
        print ("")

def show_winograd_Convolution(a,n,r,fractionsIn=FractionsInG):

    AT,G,BT,f = winograd_Filter(a,n,r,fractionsIn)

    B = BT.transpose()
    A = AT.transpose()

    print ("A = ")
    pprint(A)
    print ("")

    print ("G = ")
    pprint(G)
    print ("")

    print ("B = ")
    pprint(B)
    print ("")
    g=[1]*r
    
    if fractionsIn != FractionsInF:
        print ("Linear Convolution: B*((G*g)(A*d)) =")
        mat=convolutionVerify(a,g,n,r,B,G,A)
        pprint(mat)
        vector=pd.DataFrame(mat)
        
        return mat

    if fractionsIn == FractionsInF:
        print ("fractions = ")
        pprint(f)
        print ("")
        return f

from sympy import Rational
a=[1,2,3,4,5,6]
import time
now=time.time()
show_winograd_Convolution(a,5,3,fractionsIn=FractionsInG)
then=time.time()
print(then-now)

